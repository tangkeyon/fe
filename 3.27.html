<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    //     function Person(){
    //        // this.prototype.age1 = 12;  不能这样操作
    //         this.__proto__.age2 = 13;
    //     }
    //     Person.prototype.age4 = 14;
        

    //     var p =new Person();
       
    //     console.log(p.age2);
    //     console.log(p.age4);
    //    // console.log(p.age1);


    // function Animal(){
    // }

    // Animal.prototype.eat = function () {
    //     console.log("Animal is eating");
    //   }

    // function Cat(){

    // }  
     
    // // Cat.prototype = Animal;  JS中是依靠原型对象进行继承的不是构造方法
    //  var animal =new Animal();
    //  Cat.prototype = animal;


    // var cat =new Cat();
    // cat.eat();

    // console.log(cat instanceof Animal);

  
    /*全局上下文在代码执行之前会进行预处理
       将var声明的变量赋值为undefined类型并绑定到window属性上，预处理阶段都不会赋实际值，一律使用undefined来占位
       使用function 定义的函数会在预处理阶段就执行完毕了，执行全局代码的时候 function 定义函数的代码不会执行
       也及时函数声明提升,但是使用var func =function(){}的方式创建的函数不会进行预处理，而要等到代码执行到该处时
       才会创建函数     

    
    */


 
   
    // function a() {}
    //  var a;
    //  console.log(typeof a)//刚开始a会被赋值为undefiend后续会被覆盖为function类型


    // /*var在全局上下文中，所以在预处理时会被赋值为undefiend*/
    //  if (!(b in window)) {
    //     var b = 1;
    // }
    //   console.log(b)


 /*  不管是一个函数还是一个变量，但凡使用var来声明的，本质上都是两步：
       var a =12;

        1. var a;
        2. a=12
 
       其中第一步在预处理的时候执行
       第二步在执行全局代码之前执行


       
  */



    //   var c = 1
    //     function c(c) {
    //         console.log(c)
    //         var c = 3
    // }
    //     c(2)//c is not a function



        /*
          预处理阶段：
                    var c;
                    function c ......  c被覆盖为function类型


          全局代码执行阶段：
                     c=1
        */


        /*使用var定义的变量不是块级作用域*/

        // if(true){
        //     var a =12;
        // }

        // console.log(a);//可以访问到


            // var x = 10;
            // function fn() {
            //     console.log(x);
            // }
            // function show(f) {
            //     var x = 20;
            //     f();//等同于调用fn() fn内部没有x，所以会寻找全局变量的x
            // }
            // show(fn);//10


            // var fn = function () {
            //     console.log(fn)
            //    }
            //      fn()

            // var obj = {
            //     fn2: function () {
            //         console.log(fn2)//首先汇总当前函数作用域中寻找，没有的话再到全局作用域中寻找
            //                         //不会寻找对象的fn2属性，如果想使用的话要使用this.fn2
            //     }
            // }
            //     obj.fn2()
        



    </script>
</body>
</html>